---
title: "Classification based machine learning for trading in R"
output: html_notebook
---
 
 Loading data and calculation of moving averages

```{r, warning = FALSE}
library(tidyverse)
library(lubridate)
library(quantmod)

#Loading the data
price <- read.csv("wtiDaily.csv")

#Custom function to be able to change the data into an xts format
setup_data <- function(pricedata) {
  
       names(pricedata) <- c("Date", "Open", "High", "Low", "Close")
       dates <- parse_date_time(x = pricedata[,1], "mdy_HM", truncated = 3)
       pricedata <- pricedata[,2:5]
       pricedata <- xts(pricedata, order.by = dates)
}


price <- setup_data(price)
ema7 <- EMA(price$Close, n = 7)
ema20 <- EMA(price$Close, n = 20)
ema50 <- EMA(price$Close, n = 50)
ema70 <- EMA(price$Close, n = 70)

```

### Plotting the data since June 2017

```{r}
chartSeries(price, TA=NULL, subset = '2017-12::', theme = "white")
addEMA(n = 7,col = "orange")
addEMA(n = 20,col = "red")

```

###Feature engineering and predictior variables
Defining the type of candle (features) and dataframe to use for learning purpose

```{r}

candle.type.today <- data.frame(ifelse( price$Close > price$Open, "1", "0"))
candle.type.yesterday <- data.frame(lag(candle.type.today$Close, n = 1))
candle.type.nextday <- data.frame(lead(candle.type.today$Close, n = 1))
close.to.ema7 <- data.frame(ifelse(price$Close > ema7, "1", "0"))
close.to.ema20 <- data.frame(ifelse(price$Close > ema20, "1", "0"))
ema7.to.ema20 <- data.frame(ifelse(ema7 > ema20, "1", "0"))
dailywin <- data.frame(abs(price$Close - price$Open))
candle.nextday.win <- lead(dailywin$Close, 1)


dailyprice <- data.frame(candle.type.today,candle.type.yesterday, close.to.ema7,close.to.ema20, ema7.to.ema20, dailywin, candle.nextday.win, candle.type.nextday)


names(dailyprice) <- c("candle.type.current", "candle.type.yesterday", "close.to.ema7", "close.to.ema20", "ema7.to.ema20", "dailywin", "candle.nextday.win", "candle.type.nextday")


dailyprice <- slice(dailyprice, 21:length(dailyprice$candle.type.current))

```

          
### Training and testing formatting

```{r}
train <- dailyprice[1:400,]
test <- dailyprice[401:517,]

target <- "candle.type.nextday"
predictors.variable <- c("candle.type.today", "candle.type.yesterday", "position.to.ema7", "position.to.ema20", "ema7.to.ema20", "dailywin")
predictors <- paste(predictors.variable, collapse = "+")
formula <- as.formula(paste(target, "~", predictors, sep = ""))



#function for processing predictions
predictedReturn <- function(df, pred){
    df$pred <- pred
    df$prediReturn <- ifelse(df$candle.type.nextday != df$pred, -df$candle.nextday.win, df$candle.nextday.win)
    df$cumReturn <- cumsum(df$prediReturn)
    return(df)    
}


plot(price$Close[21:536,])  
```
```{r, message= FALSE}

library(keras)

x_train <- as.matrix(train[,-(7:8)])
y_train <- as.matrix(train[,8])
x_test <- as.matrix(test[1:116,-(7:8)])
y_test <- as.matrix(test[1:116,8])

model <- keras_model_sequential() %>%
  layer_dense(units = 20, activation = "relu", input_shape = c(6)) %>%
  layer_dense(units = 20, activation = "relu") %>%
  layer_dense(units = 16, activation = "relu") %>%
  layer_dense(units = 16, activation = "relu") %>%
  layer_dense(units = 1, activation = "sigmoid")
#
model %>% compile(
  optimizer = "rmsprop",
  loss = "binary_crossentropy",
   metrics = c("accuracy")
 )

history <- model %>% fit(
  x_train,
  y_train,
   epochs = 30,
   batch_size = 40,
   validation_data = list(x_test, y_test)
 )
#
 results <- model %>% evaluate(x_test, y_test)
# results
#
dp.predi <- model %>% predict(x_test)
dp.predi <- ifelse(dp.predi < 0.5, 0, 1)

dl.test <- predictedReturn(test[1:116,], dp.predi)

```

Plots

```{r}
plot(dl.test$prediReturn, type = "line")
plot(dl.test$cumReturn, type = "line")

dl.misclsserror <- mean(dl.test$candle.type.nextday != dl.test$pred)
print(paste("Accuracy", 1-dl.misclsserror))
```

